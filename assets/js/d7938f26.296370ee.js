"use strict";(self.webpackChunkbulldog_computer_club_website=self.webpackChunkbulldog_computer_club_website||[]).push([[751],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,d=c["".concat(s,".").concat(m)]||c[m]||h[m]||i;return n?o.createElement(d,a(a({ref:t},u),{},{components:n})):o.createElement(d,a({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var p=2;p<i;p++)a[p]=n[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6466:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var o=n(7462),r=(n(7294),n(3905));const i={title:"Two-Pointers on Sorted Sequences",sidebar_position:7},a=void 0,l={unversionedId:"ccc/two-pointers",id:"ccc/two-pointers",title:"Two-Pointers on Sorted Sequences",description:"An introduction to the extremely useful two-pointers technique.",source:"@site/docs/ccc/two-pointers.md",sourceDirName:"ccc",slug:"/ccc/two-pointers",permalink:"/docs/ccc/two-pointers",draft:!1,editUrl:"https://github.com/bulldog-computer-club/bulldog-computer-club.github.io/edit/main/docs/ccc/two-pointers.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Two-Pointers on Sorted Sequences",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Lists, Stacks, and Queues",permalink:"/docs/ccc/lists-stacks-queues"},next:{title:"Introduction",permalink:"/docs/weekly-challenges/introduction"}},s={},p=[{value:"Properties of sorted sequences",id:"properties-of-sorted-sequences",level:2},{value:"Problem: Two-Sum",id:"problem-two-sum",level:2},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Solving Two-Sum using Two Pointers",id:"solving-two-sum-using-two-pointers",level:2},{value:"Question",id:"question",level:3},{value:"Related Problem",id:"related-problem",level:2},{value:"Example",id:"example",level:2}],u={toc:p};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An introduction to the extremely useful ",(0,r.kt)("em",{parentName:"p"},"two-pointers")," technique."),(0,r.kt)("h1",{id:"what-is-the-two-pointers-technique"},"What is the two-pointers technique?"),(0,r.kt)("p",null,"The general idea between the two-pointers technique is simple. You have two variables pointing to elements within a sequence which you move around. Typically, the task is to search for some elements / subsequence that match some criteria."),(0,r.kt)("h1",{id:"two-pointers-on-sorted-sequences"},"Two-Pointers on sorted sequences"),(0,r.kt)("p",null,"Perhaps the most simple application of two pointers is to search for a pair of elements within an array/list matching some criteria -- for example, finding two elements that have a given sum."),(0,r.kt)("p",null,"Let's begin by reviewing some basic properties of sorted sequences."),(0,r.kt)("h2",{id:"properties-of-sorted-sequences"},"Properties of sorted sequences"),(0,r.kt)("p",null,"Generally, when we refer to sorted sequences, we are talking about sequences sorted in ascending order. That is, the first element is the smallest, the second the second smallest, and so on. Thus,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6] => sorted\n[6, 6, 3, 1] => sorted in reverse\n")),(0,r.kt)("p",null,"To formalize this definition, we could say that a sorted sequence is one where each element is not less than the previous one, with the exception of the first element."),(0,r.kt)("p",null,"Based on the definition we can identify two basic properties, which directly follow from the definition."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Given an element, the previous element either does not exist or has a value ",(0,r.kt)("strong",{parentName:"li"},"not greater")," than the current element."),(0,r.kt)("li",{parentName:"ol"},"Given an element, the next element either does not exist or has a value ",(0,r.kt)("strong",{parentName:"li"},"not less")," than the current element.")),(0,r.kt)("p",null,"Though these two properties may seem quite basic (and, in truth, they are basic), combining them can result in elegant and efficient programs that are not necessarily trivial."),(0,r.kt)("h2",{id:"problem-two-sum"},"Problem: Two-Sum"),(0,r.kt)("p",null,"Given a sorted list of integers $X$ and an integer $K$, determine whether there is a pair of elements that sum up to $K$."),(0,r.kt)("h4",{id:"example-1"},"Example 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [1, 3, 6, 6, 7, 9, 13, 22, 25]\nK = 12\n")),(0,r.kt)("p",null,"There are multiple pairs that sum up to $12$ in $X$. Here is one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n       ^  ^\n6 + 6 = 12\n")),(0,r.kt)("p",null,"and here is the other:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^           ^\n3 + 9 = 12\n")),(0,r.kt)("h4",{id:"example-2"},"Example 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [12, 17, 18]\nK = 6\n")),(0,r.kt)("p",null,"There is no pair of integers in $X$ that sum up to $6$."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Can you come up with an efficient solution to this problem?")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Approach 1: Brute Force"),(0,r.kt)("p",null,(0,r.kt)("p",null,"We can go through all pairs in $X$ and see if they sum up to $K$. For example, given"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [1, 3, 6, 6, 7, 9, 13, 22, 25]\nK = 12\n")),(0,r.kt)("p",null,"we would visit the pairs in the following order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^  ^\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^     ^\n\n...\n\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^                          ^\n\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^  ^\n\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^     ^\n\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^        ^\n\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^           ^\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"def solve(X, k):\n    for i in range(len(X)):\n        for j in range(i + 1, len(X)):\n            if X[i] + X[j] == k:\n                return True\n    return False\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Time & Space Complexity")),(0,r.kt)("p",null,"There are $n \\choose 2$ distinct pairs in a sequence of length $n$, which is in $O(n^2)$. Thus our solution takes quadratic time.\nAs we only need a few integer values, the time complexity is $O(1)$."),(0,r.kt)("p",null,"This is the easiest approach, but as our analysis shows, it is not efficient for large inputs.\nIf we got a sequence of length $100,000$, for example, our code would spend a lot of time working before outputting an answer."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Approach 2: Hash Sets"),(0,r.kt)("p",null,(0,r.kt)("p",null,"Let's take a step back and look at the problem. We are looking for a pair of elements $(x, y)$ such that $x + y = K$."),(0,r.kt)("p",null,"We can rewrite this equation as $y = K - x$, which is clearly equivalent. The benefit of this form is that given a value $x$\nwe know that the value that completes the pair must be $K - x$."),(0,r.kt)("p",null,"Given this insight, we can consider a different approach: instead of going through all pairs, let's just go through all elements one by one.\nThen, for each element, we can search for the value that completes the pair."),(0,r.kt)("p",null,"One way to do this is to maintain an auxiliary set of values that we have seen before. That is, after we go through an element, we add it to a set.\nThen, instead of explicitly searching for a value that completes the pair, we can query the set.\nThis is much faster as sets are implemented using a data structure called hash tables, which provide constant time lookups on average."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"def solve(X, k):\n    seen = set()\n    for x in X:\n        if k - x in seen:\n            return True # we currently have value x and we know that we've previously seen the value k - x; these add up to k.\n        seen.add(x)\n    return False\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Time & Space Complexity")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"set"),"s are implemented as hash tables which provide $O(1)$ lookups on average. Thus the time complexity is $O(n)$."),(0,r.kt)("p",null,"Sadly, to improve our time complexity, we had to use an auxiliary set of elements. In the worst case, ",(0,r.kt)("inlineCode",{parentName:"p"},"seen")," will contain all the elements\nin ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", meaning that our time complexity is also $O(n)$."))),(0,r.kt)("h2",{id:"solving-two-sum-using-two-pointers"},"Solving Two-Sum using Two Pointers"),(0,r.kt)("p",null,"Above, we went through two different approaches to solve this problem. The first had a time complexity of $O(n^2)$ and a space complexity of $O(1)$, while\nthe second had a time complexity of $O(n)$ and a space complexity of $O(n)$."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Can we do better?")),(0,r.kt)("p",null,"It turns out... we can. And, as you probably expect, the key lies in using the two-pointers technique."),(0,r.kt)("p",null,"Let's jump straight into an example. Let's again consider the first sample case of"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [1, 3, 6, 6, 7, 9, 13, 22, 25]\nK = 12\n")),(0,r.kt)("p",null,"This time, let's start with a pointer to the first element and the last element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^                          ^\n")),(0,r.kt)("p",null,"$1 + 25 = 26$, which is greater than $12$. To get closer to $12$, we need to ",(0,r.kt)("strong",{parentName:"p"},"decrease the sum of the pair of elements"),".\nWe can do that by moving the right pointer one position left."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Claim 1:")," Moving the right pointer leftward is guaranteed to either 1) have no effect on the sum or 2) decrease the sum.",(0,r.kt)("br",null),"\n",(0,r.kt)("strong",{parentName:"p"},"Proof:")," Refer back to the properties of sorted sequences discussed earlier. We state:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Given an element, the previous element either does not exist or has a value not greater than the current element.")),(0,r.kt)("p",null,"Therefore, moving the right pointer leftward yields a value that is not greater than the current value."),(0,r.kt)("p",null,"After moving the right pointer leftward, we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^                      ^\n")),(0,r.kt)("p",null,"$1 + 22 = 23 > 12$. Still too large, so let's continue moving it leftward."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^                  ^\n[1, 3, 6, 6, 7, 9, 13, 22, 25]\n ^              ^\n")),(0,r.kt)("p",null,"Now we've got $1 + 9 = 10$. This is less than $12$. Can you think of what we need to do now?"),(0,r.kt)("p",null,"Indeed -- we need to ",(0,r.kt)("strong",{parentName:"p"},"increase the sum of the pair of elements"),". Similarly, we can do this by moving the left pointer one position right."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Claim 2:")," Moving the left pointer rightward is guaranteed to either 1) have no effect on the sum or 2) increase the sum.",(0,r.kt)("br",null),"\n",(0,r.kt)("strong",{parentName:"p"},"Proof:")," Again, refer to the properties of sorted sequences."),(0,r.kt)("p",null,"After moving the left pointer rightward, we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1, 3, 6, 6, 7, 9, 13, 22, 25]\n    ^           ^\n")),(0,r.kt)("p",null,"$3 + 9 = 12$, so we're done."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"def solve(X, k):\n    lo, hi = 0, len(X) - 1\n    while lo < hi: # stop once the two pointers meet\n        s = X[lo] + X[hi]\n        if s > k:\n            hi -= 1 # if the sum is too large, move right ptr\n        elif s == k:\n            return True\n        else:\n            lo += 1 # if the sum is too small, move left ptr\n    return False\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Time & Space Complexity")),(0,r.kt)("p",null,"Observe that in each iteration of the ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loop, either ",(0,r.kt)("inlineCode",{parentName:"p"},"hi")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"lo")," moves closer to the other by one.\nAs they start $n$ positions apart, there can only be $n$ iterations until they cross (and the loop breaks.)"),(0,r.kt)("p",null,"Thus, the time complexity is $O(n)$ while the space complexity is $O(1)$, which is better than both of the solutions above -- as promised."),(0,r.kt)("h3",{id:"question"},"Question"),(0,r.kt)("p",null,"What happens if $X$ is not sorted? Does this algorithm still work?"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Click to reveal"),(0,r.kt)("p",null,(0,r.kt)("p",null,"No, this algorithm will not work without modifications. This is because the properties of a sorted sequence only hold on, well, a sorted sequence."),(0,r.kt)("p",null,"Here is an example on which the algorithm above fails to find an answer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [4, 1, -1, 3, 4, 3]\nK = 6\n")),(0,r.kt)("p",null,"Here is a visualization of the movement of the pointers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[4, 2, -1, 3, 4, 3]\n ^               ^\n[4, 2, -1, 3, 4, 3]\n ^            ^\n[4, 2, -1, 3, 4, 3]\n ^         ^\n[4, 2, -1, 3, 4, 3]\n ^      ^\n[4, 2, -1, 3, 4, 3]\n    ^  ^\n[4, 2, -1, 3, 4, 3]\n   (loop breaks)\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"However"),", there is a simple way to make it work on unsorted sequences. Can you think of it?"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Click to reveal"),(0,r.kt)("p",null,"Sort the sequence between running the two pointers algorithm on it! :)")))),(0,r.kt)("h2",{id:"related-problem"},"Related Problem"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2020/day/1"},"Advent of Code 2020 Day 1: Report Repair"),"."),(0,r.kt)("p",null,"Try solving this problem using the two-pointers technique described above."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"As with all AoC questions, there are two parts to this problem; the first is the two-sum problem discussed previously, while the\nsecond is a variant of it which does not ask for a pair of numbers but rather a triplet.")),(0,r.kt)("h1",{id:"generalizing-two-pointers"},"Generalizing Two-Pointers"),(0,r.kt)("p",null,"It's not difficult to \"generalize\" the two-pointers technique to other problems -- as it's really as simple as having two pointers\nwhich move around."),(0,r.kt)("p",null,"Here is a problem to mull over before next week's content."),(0,r.kt)("p",null,"Given a list (not necessarily sorted) of integers $X$, compute the length of the longest contiguous subsequence which is comprised of distinct elements."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"X = [5, 4, 2, 3, 4, 6, 7, 8, 9, 9]\n")),(0,r.kt)("p",null,"The longest sequence that meets the criteria given is the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[5, 4, 2, 3, 4, 6, 7, 8, 9, 9]\n       ^                 ^\n")),(0,r.kt)("p",null,"...which has length $7$."))}h.isMDXComponent=!0}}]);